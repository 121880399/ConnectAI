## 前文提要
上篇文章中，我们介绍了神经元的另外一个特性，就是忽略微小的输入信号。并且通过激活函数来实现这一机制。最后我们使用感知机模拟了逻辑电路中的门。在文章的末尾给大家留了一个作业，如何使用感知机来实现异或门？

## 多层感知机

实际上，用之前介绍的感知机是无法实现异或门的。那么为什么感知机可以实现与门，或门，与非门，却无法实现异或门呢？我们来回顾一下或门的实现，对于或门来说，只要有一个输入值为1，输出结果就为1。表现在坐标轴上就如下图所示：
![](https://files.mdnice.com/user/70350/35d5cd5b-ce89-46f0-bd4a-dd1b7d0b1754.png)

从图中我们可以看见，结果为1的情况都聚集在斜线的上半部分，结果为0的情况都在斜线的下半部分。这说明或门的结果是可以被线性分割的。

我们再来看异或门,异或门的特点是输入方中只有1方为1时，输出才会是1，其余都为0。
![](https://files.mdnice.com/user/70350/d0c1de7c-b333-4183-86bd-4ca189adeef8.png)

我们将输出结果为1的用三角形表示，输出结果为0的用圆形表示。可以看出来我们没有办法用一条直线同时将三角形和圆形分割开。这说明异或门没有办法被线性分割。

所以感知机的局限性就在于它只能解决线性可分的问题，无法表示复杂的非线性关系。

真的没有办法了吗？如果我们将与门，或门，与非门进行组合呢？多种门的组合是否可以实现异或门？
![](https://files.mdnice.com/user/70350/e9a593ce-fef0-4da4-9816-a09c3bc3179e.png)

现在思考一下，图中三个问号处应该使用哪种门，才能实现异或门的功能。

这里$x_1$，$x_2$表示输入信号，y表示输出信号。

现在公布答案：

![](https://files.mdnice.com/user/70350/cb448e2b-827e-4354-87ba-465a59532419.png)


我们来验证一下：
| $x_1$ | $x_2$ | $s_1$ | $s_2$ | y    |
| ----- | ----- | ----- | ----- | ---- |
| 0     | 0     | 1     | 0     | 0    |
| 1     | 0     | 1     | 1     | 1    |
| 0     | 1     | 1     | 1     | 1    |
| 1     | 1     | 0     | 1     | 0    |

从表格中可以看见，我们通过组合与非门，或门，与门成功的实现了异或门的功能。

代码实现:
```python
  #异或门实现
  def xor(x1,x2):
      s1 = nand(x1,x2)
      s2 = or(x1,x2)
      y = and(s1,s2)
      return y
```

异或门的实现给了我们什么启发呢？
我们在实现异或门时发现单层感知机只能进行线性分割，但是异或门恰恰不能使用线性进行分割。于是我们将感知机模拟的多个不同的门进行了组合，增加了一层实现了异或门的功能。这种叠加了多个感知机而组成的系统我们称为**多层感知机**。

## 总结
本小节为大家介绍了什么是多层感知机，以及多层感知机能解决什么问题。我们知道每一个感知机的实现都是在模拟神经元，多层感知机也就是每一层会有多个模拟神经元。这种按层连接多个神经元的系统，也就是我们最初的**神经网络**。